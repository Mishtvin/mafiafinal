Анализ текущей архитектуры
1. Проблема при подключении нового пользователя

Инициализация камеры как выключенной:
При подключении нового пользователя сервер вызывает initializeUserCamera(userId), что устанавливает камеру в состояние «выключено» по умолчанию.

Рассылка состояния всем клиентам:
Это состояние (выключено) отправляется всем клиентам, включая тех, у кого камера уже активирована.

Отсутствие различия обновлений:
Клиенты не могут отличить, что обновление касается только нового пользователя или глобальное изменение, что приводит к нежелательной перезаписи локального состояния.

2. Проблема при изменении состояния камеры

Рассылка обновления всем пользователям:
При изменении состояния камеры (включение/выключение) сервер отправляет сообщение всем клиентам.

Нет проверки принадлежности:
Клиентская логика в handleMessage не проверяет, относится ли обновление к его собственной камере или к камере другого пользователя.

Возможное перезаписывание локального состояния:
Если клиент уже изменил состояние камеры (например, физически включил её через LiveKit API), приходящее обновление может перезаписать локальное состояние, даже если оно уже синхронизировано.

Предлагаемые решения
1. Разделение типов сообщений

Специализированное сообщение для инициализации:
Вместо того чтобы рассылавать одно и то же сообщение для всех, можно использовать отдельный тип сообщения для первичной инициализации (all_camera_states), которое отправляется только новому пользователю.

Сообщения для изменений:
Для изменения состояния можно использовать individual_camera_update с дополнительными параметрами, позволяющими клиенту понять, что это обновление от другого пользователя или подтверждение его собственного действия.

2. Улучшение логики обработки на клиенте

Проверка идентификатора пользователя:
В функции handleMessage добавить проверку: если пришедшее обновление относится к текущему пользователю, то обновление должно служить лишь для проверки соответствия физического состояния (через LiveKit) и UI, а не для принудительной замены текущего состояния.

Сохранение локального состояния:
Если пользователь уже изменил состояние камеры (и это состояние сохранено в sessionStorage), то обновление с сервера должно учитываться только при наличии расхождения между UI и реальным состоянием камеры.

Флаг подтверждения:
После успешного изменения физического состояния камеры клиент может отправить подтверждающее сообщение, чтобы сервер знал, что состояние успешно обновлено, и чтобы клиенты не пытались его перезаписывать.

3. Расширение данных обновления

Добавление метаданных:
Добавление таких полей, как origin (например, local или remote) или временной метки, поможет клиентам различать, откуда поступило обновление и насколько оно актуально.

Версионность состояния:
Использование версии или счётчика изменений позволит клиенту сравнивать входящие обновления с текущим состоянием и обновлять UI только при необходимости.

4. Улучшение серверной логики

Избирательная рассылка:
При инициализации нового пользователя сервер может отправлять состояние камеры только конкретному пользователю, а не транслировать его всем клиентам. Это предотвратит нежелательное изменение состояния у уже подключённых пользователей.

Контроль обновлений:
Сервер может добавлять дополнительную логику для отслеживания, были ли изменения состояния инициированы пользователем или являются частью начальной синхронизации, и рассылать сообщения соответствующего типа.

Итог
Чтобы решить описанные проблемы, необходимо:

Разделить типы сообщений: различать инициализационные и обновляющие сообщения.

Модифицировать клиентскую логику: добавить проверку принадлежности обновления (сравнение userId и дополнительными метаданными).

Изменить серверную логику: отправлять сообщения выборочно и добавлять метаданные (например, временные метки, флаги источника), чтобы клиенты могли корректно обрабатывать изменения без перезаписывания локального состояния.

Эти меры помогут избежать конфликтов между физическим состоянием камеры и UI, а также предотвратят нежелательное перезаписывание активных состояний при подключении нового пользователя.